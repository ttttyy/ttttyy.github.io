[{"categories":null,"content":"概述 RSA是一种广泛使用的非对称加密算法，由由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的，RSA就是他们三人姓氏头字母组成的。 对极大整数做因式分解的难度决定了RSA算法的可靠性，目前被破解的最长的RSA密钥为829位。只要密钥的长度足够长，用RSA加密的信息可以认为是无法破解的。下面将介绍与RSA算法相关的数学概念，RSA的算法流程及正确性证明。 ","date":"2022-10-29","objectID":"/rsa/:0:1","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"与RSA算法相关的数学概念 互质 如果两个正整数除了1之外，没有别的公因数，就称这两个数互质。关于互质，有以下几个推论： 任意两个质数构成互质关系； 一个数是质数，另一个数只要不是它的倍数，则这两个数互质； 如果两个数中，较大的那个数是质数，则这两个数互质； $1$和任意自然数互质； $p$是大于$1$的整数，则$p$和$p-1$互质； $p$是大于$1$的奇数，则$p$和$p-2$互质。 欧拉函数 算术基本定理 任意一个大于$1$的自然数，要么本身是质数，要么可以写成两个或以上质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。 在数论中，对正整数$n$，欧拉函数$\\varphi(n)$是小于等于$n$的正整数中与$n$互质的数的数目。 \\begin{equation} \\varphi(n)= p_1^{k_1-1}p_2^{k_2-1}\\cdots p_r{k_r-1}(p_1-1)(p_2-1)\\cdots(p_r-1) \\end{equation} $p_1，p_2 \\dots p_r$是$n$的质因子，该函数也可等价的写成 \\begin{equation} \\varphi(n)=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_r}) \\end{equation} 欧拉定理 欧拉定理是RSA算法的核心，理解了这个定理，就理解了RSA。欧拉定理指 如果两个正整数$a$和$n$互质，$\\varphi(n)$是$n$的欧拉函数，则 \\begin{equation} a^{\\varphi(n)} \\equiv 1 \\ (mod \\ n) \\end{equation} 欧拉定理有一个特殊情况，假设正整数$a$与质数$p$互质，因为质数$p$的欧拉函数$\\varphi(n)$等于$p-1$，则欧拉定理可以写成 \\begin{equation} a^{p-1} \\equiv 1 \\ (mod \\ n) \\end{equation} 这就是著名的费马小定理，它是欧拉函数的特例。 模反元素 如果两个正整数$a$和$n$互质，那么一定可以找到整数$b$，使得$ab-1$被$n$整除，这是$b$就叫做$a$的模反元素。 欧拉定理可以证明模反元素必然存在 \\begin{equation} a^{\\varphi(n)}=a \\times a^{\\varphi(n)-1} \\equiv 1 \\ (mod \\ n) \\end{equation} 可以看到，$a^{\\varphi(n)-1}$就是$a$的模反元素。 ","date":"2022-10-29","objectID":"/rsa/:0:2","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"RSA密钥生成步骤 随机选择两个不相等的质数$p$和$q$。 假设$p=61，q=53$ 计算$p$和$q$的乘积$n$，$n = pq = 61 \\times 53 = 3233$ 计算$n$的欧拉函数$\\varphi(n)$，根据公式$\\varphi(n)=(p-1)(q-1)=3120$ 欧拉函数性质 如果$p$为质数，则$\\varphi(p) = p-1$; 如果$n$可以分解成两个互质的整数$p$和$q$之积，则$\\varphi(n)=\\varphi(p)\\varphi(q)$ 在$1$到$\\varphi(n)$之间随机选择一个与$\\varphi(n)$互质的整数$e$ 计算$e$对于$\\varphi(n)$的模反元素$d$。 \\begin{equation} ed \\equiv 1 \\ (mod \\ \\varphi(n)) \\end{equation} 上式等价于 \\begin{equation} ed - 1 = k\\varphi(n) \\end{equation} 于是，找到模反元素$d$，实质上就是对下面这个二元一次方程求解 \\begin{equation} ex+\\varphi(n)y = 1 \\end{equation} 此方程可以用扩展欧几里得算法扩展求解，通过计算，得到$d=2753$。 将$n$和$e$封装成公钥，$n$和$d$封装成私钥。 ","date":"2022-10-29","objectID":"/rsa/:0:3","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"RSA算法的可靠性 公钥$(n，e)$是公开的，只要得知了$d$，就等于私钥泄露，即已知$n$和$e$，是否可能推导出$d$? Question $ed \\equiv 1 \\ (mod \\ \\varphi(n))$。只有知道$e$和$ \\varphi(n) $，才能算出$d$。 $n=pq$，只有将$n$因数分解，才能算出$p$和$q$。 如果$n$可以分解成两个互质的整数$p$和$q$之积，则$\\varphi(n)=\\varphi(p)\\varphi(q)$ 但是，分解质因数是很困难的，目前除了暴力破解没有别的办法，因此RSA算法的可靠性是基于这个困难的数学问题。 ","date":"2022-10-29","objectID":"/rsa/:0:4","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"RSA算法的加密与解密 假设要发送的信息是$m$，加密后的信息为$c$，则加密过程为 \\begin{equation} c=m^e \\ mod \\ n \\end{equation} Warning 由数论知识可知，$m \\ mod \\ n$的值域是$[0，n)$，因此$m$的值域不能超过$pm$的值域，否则将产生碰撞，即$m$必须小于$n$。 解密过程为 \\begin{equation} m = c^d \\ mod \\ n \\end{equation} ","date":"2022-10-29","objectID":"/rsa/:0:5","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"私钥解密的证明 证明私钥能解密，即是证明下式： \\begin{equation} c^d \\equiv m \\ (mod \\ n) \\end{equation} 由加密公式可得： \\begin{equation} c=m^e-kn \\end{equation} 将其代入解密公式(10)， \\begin{equation} (m^e-kn)^d \\equiv m \\ (mod \\ n) \\end{equation} 等价于 \\begin{equation} m^{ed} \\equiv m \\ (mod \\ n) \\end{equation} Tip 对$(m^e-kn)^d$二项式展开，除第一项外其他项都包含$kn$，都可以被$n$整除 由于 \\begin{equation} ed \\equiv 1 \\ (mod \\ \\varphi(n)) \\end{equation} 所以 \\begin{equation} ed = h\\varphi(n)+1 \\end{equation} 将上式代入(14)： \\begin{equation} m^{h\\varphi(n)+1} \\equiv m \\ (mod \\ n) \\end{equation} 接下来，分两种情况讨论， $m$和$n$互质 根据欧拉定理， \\begin{equation} m^{\\varphi(n)} \\equiv 1 \\ (mod \\ n) \\end{equation} 得到 \\begin{equation} (m^{\\varphi(n)})^h \\times m \\equiv m \\ (mod \\ n) \\end{equation} 得证。 $m$和$n$不是互质关系 由于$n=pq$，则$m$必然等于$kp$或$kq$。 假设$m=kp$，此时$k$和$q$必然互质，根据欧拉定理知： \\begin{equation} (kp)^{q-1} \\equiv 1 \\ (mod \\ q) \\end{equation} 进一步得到 \\begin{equation} [(kp)^{q-1}]^{h(p-1)} \\times kp \\equiv kp \\ (mod \\ q) \\end{equation} 将式(16)带入上式 \\begin{equation} (kp)^{ed} \\equiv kp \\ (mod \\ q) \\end{equation} 即 \\begin{equation} (kp)^{ed} \\equiv tq + kp \\end{equation} 这时$t$必然能被$p$整除，即有$t=t^{\\prime}p$ Tip 这是因为上式两边同时除以$p$，可知等式左边必然能够整除，因此右边$t\\frac{q}{p}+p$也必然是一个整数，又因为$p$和$q$互质，则$\\frac{t}{p}$必然是一个整数，才能保证等式成立。 因此上式可写为 \\begin{equation} (kp)^{ed} = t^{\\prime}pq+kp \\end{equation} 将$m=kp$，$n=pq$代入得 \\begin{equation} m^{ed}=t^{prime}n+m \\end{equation} 即 \\begin{equation} m^{ed} \\equiv m \\ (mod \\ n) \\end{equation} 得证。 ","date":"2022-10-29","objectID":"/rsa/:0:6","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"参考文献 [1] RSA算法原理（一） [2] RSA算法原理（二） [3] RSA算法的数学原理与证明 ","date":"2022-10-29","objectID":"/rsa/:0:7","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"xxxxxxxxx $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\u003e\u003e B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} int main(){ printf(\"hello\"); } ","date":"2022-08-11","objectID":"/first/:0:0","tags":null,"title":"第一篇文章","uri":"/first/"},{"categories":null,"content":" 为了解决主从备份模型无法同时实现高吞吐量，高可用性和强一致性的问题，论文提出了一种链复制技术，其主要思路是所有节点链式连接，查询操作只发送到tail节点，而更新操作则从头节点head依次更新到tail，tail回复消息给客户端。 ","date":"2022-05-19","objectID":"/chain-replication/:0:0","tags":["分布式","Chain Replication","论文"],"title":"Chain Replication论文阅读笔记","uri":"/chain-replication/"},{"categories":null,"content":"链复制协议 如果集群中有T个节点，该协议最多容忍t-1个节点失效。节点间还要保持健壮的FIFO通信，该协议不区分发送失败和请求被忽略。 $ Hist_{objID}^{T} $表示TAIL通过的update请求序列，上标表示节点的序号。 $Pending_{objID}$表示链收到但是没有被TAIL处理的请求。 fail-stop 如果失败，宁可停止服务，也不能进行错误的状态转移(强一致性)， 环境有能力监测到故障。 处理节点故障 为了检测故障，该协议假设了一个永不会失败的master节点，其作用有： 监测节点失败 在删除失败节点后向链上的每个节点通知其新的前驱和后置节点 通知客户端链的首尾节点 头节点故障 头节点的后继节点成为新的头节点，可以看作是T2，对一致性没有影响。 尾节点故障 尾节点的前驱节点成为新的尾节点，由倒数第二个节点处理过的Pending请求会变成已被尾结点处理，也就是重复了T3，仍然满足一致性。 中间节点故障 每个节点都存储一个sent_i节点，保存发送给后继节点但没有被尾节点处理的请求。\rmaster告知节点S+你前面的S失败； S+通知master最后更新的请求序号sn； mater通知S-它的新角色以及sn； S+向S-同步至sn。 新增节点 新增节点$T^+$增加在链尾，尾节点$T$将$Hist_{objID}^T$复制到$Hist_{objID}^{T^+}$，在复制过程中，同步处理客户端的请求，并将更新加入到$Send_T$,满足$Hist_{objID}^T = Hist_{objID}^{T+} + Sent_T$ 之后，$T$丢弃查询请求，把$Sent_T$发送给$T^+$，master通知客户端$T^+$成为新的链尾。 ","date":"2022-05-19","objectID":"/chain-replication/:0:1","tags":["分布式","Chain Replication","论文"],"title":"Chain Replication论文阅读笔记","uri":"/chain-replication/"},{"categories":null,"content":" ZooKeeper是一个分布式开源协调服务，它为更加复杂的协调原语提供了一个简单高效的内核，并为开发者提供了API以便他们能开发自己的协调原语。 ","date":"2022-05-18","objectID":"/zookeeper/:0:0","tags":["分布式","ZooKeeper"],"title":"ZooKeeper论文阅读笔记","uri":"/zookeeper/"},{"categories":null,"content":"ZooKeeper服务 服务概览 ZooKeeper给clients提供一个数据节点(znode)集合的抽象，client可以对这些znode进行数据操作，这些节点按层次结构组织。 client可以创造两种znode, regular, client可以显式地创建和删除这些znode ephermeral,client可以显示地创建或删除，也可以让系统在创建了znode的session结束时自动删除 另外，client可以在创建znode时设置sequential flag，拥有sequential flag的znode会有一个单调增的sequence value,即父节点的sequence value小于子节点的值。 ZooKeeper实现了watch机制，client在数据变化时可以不用轮询就可以及时收到通知。一个watch只会在一个session中触发一次。如果在一个session中数据变化了两次，client只会收到一次通知，因为在数据第一次变化后watch已被触发失效了。 This is a tip session：一个client从连接到ZooKeeper到断开连接的过程称为一个session Client API create(path, data, flags)：在path下新建一个znode，将data保存在其中，flags用来设置znode类型，以及设置sequential标志； delete(path, version)：如果version参数匹配，删除path对应的znode； exists(path, watch)：检查path对应的znode是否存在，watch让client观测这个znode； getdata(path, watch)：返回znode对应的数据和元数据，包括版本信息； setdata(path, data, version): 如果version参数匹配，将data写入znode； getChildren(path, watch)：返回znode的子节点 sync(path)：等待所有未决的更新。 以上这些API都有阻塞和非阻塞两个版本。 ","date":"2022-05-18","objectID":"/zookeeper/:0:1","tags":["分布式","ZooKeeper"],"title":"ZooKeeper论文阅读笔记","uri":"/zookeeper/"},{"categories":null,"content":"ZooKeeper保证 所有更新串行写入； 同一个client的请求按先到先服务顺序执行 ","date":"2022-05-18","objectID":"/zookeeper/:0:2","tags":["分布式","ZooKeeper"],"title":"ZooKeeper论文阅读笔记","uri":"/zookeeper/"},{"categories":null,"content":"原语示例 配置管理 将所有配置存储到一个znode中，其他节点通过watch机制获取更新。 会合 有些分布式系统包含一个主节点和多个工作节点，但这些节点都通过一个调度器调度，工作节点不知道主节点的地址和端口等配置信息。因此可以将主节点信息放入一个znode，工作节点通过znode获取主节点信息。 组成员关系 当一个组成员进程启动时，会在组对应的znode下创建一个ephemeral类型的子节点，该进程结束后子节点自动删除。进程也可以通过组znode的子节点获取组信息。 简单锁 锁可以通过创建一个ephemeral znode实现，如果创建成功，client获取锁。如果已经存在锁，client只能等待之前的锁被删除后才能创建自己的锁。 读写锁 写锁与普通锁类似，与其他锁互斥。而读锁间互相兼容，与写锁互斥。 双栅栏 双栅栏用来保证多个client的计算同时开始和同时结束。client开始计算前添加znode到barrier的znode之下，结束计算时删除znode。当barrier的znode下的子节点数达到阈值后才会启动计算。client可以等待一个特殊的ready的znode的创建，当数量到达阈值后创建。client退出的时候需要等待子znode全部被删除，同样可以通过删除ready删除。 ","date":"2022-05-18","objectID":"/zookeeper/:0:3","tags":["分布式","ZooKeeper"],"title":"ZooKeeper论文阅读笔记","uri":"/zookeeper/"},{"categories":null,"content":"ZooKeeper实现 请求处理器 leader收到写入请求后，会将其转换为幂等的事务，根据请求内容计算出新的数据、版本号和时间戳，等待应用到数据库中。 原子广播 ZooKeeper使用原子广播协议Zab,Zab使用简单多数投票确保一致性。Zab保证广播收到和发出的顺序是一致的。leader节点广播之前需要确保已经收到了前一个leader的广播 多副本数据库 当服务器故障后，使用周期性的快照和快照之后的日志恢复。创建快照的时候并不需要锁定，因为事务都是幂等的，因此再次应用已经应用的修改没有影响。 客户端-服务器交互 当server执行一个写入操作时，会通知watch的client并清楚watch。每个服务器只负责通知自己连接的客户端； 每个读取请求对应着一个zxid，对应服务器上看到的最后一个写入事务的ID。因为读取是在服务器本地进行，可能在读取之前的一些写入没有同步到客户端连接的服务器，ZooKeeper提供了sync操作，保证sync之后的读取操作都能够获得发生在sync之前的写入结果； 如果一个client连接到一个新的server，新server通过比较zxid,server zxid要大于client zxid,确保它的view不能低于client的view； 在超时时间内，server没有收到client的消息，server就会认为client session failure。因此，client要在在没有活动时发送heartbeat避免超时。 ","date":"2022-05-18","objectID":"/zookeeper/:0:4","tags":["分布式","ZooKeeper"],"title":"ZooKeeper论文阅读笔记","uri":"/zookeeper/"},{"categories":null,"content":"About LoveIt","date":"2019-08-02","objectID":"/about/","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"一个普通计科研究生罢了 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]