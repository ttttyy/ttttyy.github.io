[{"categories":null,"content":"群 定义 群$(G,\\cdot)$是由非空集合$G$和二元运算$\\cdot$构成的，且符合以下四个性质的数学结构。 封闭性：对于所有$G$中的$a$，$b$，运算$a\\cdot b$的结果也在$G$中； 结合律：对于所有$G$中的$a$，$b$和$c$，等式$(a\\cdot b)\\cdot c = a\\cdot (b \\cdot c)$成立； 单位元：存在$G$中的一个元素$e$，使得对于所有$G$中的元素$a$，总有等式$e \\cdot a = a \\cdot e = a$成立； 逆元：对于每个$G$中的$a$，存在$G$中的一个元素$b$使得总有$a \\cdot b = b \\cdot a = e$，则称$b$为$a$在$G$中的逆元，$e$为单位元。 例如，整数集和整数间的加法$(\\mathbb{Z},+)$构成一个群，单位元是$0$，一个整数的逆元是它的相反数。 相关概念 若代数结构$(G,\\cdot)$满足封闭性和结合律性质，则称$(G,\\cdot)$为一个半群。 对于$G$中的所有$a$，$b$,等式$a\\cdot b = b \\cdot a$成立，则群$(G,\\cdot)$为可交换群。 一个群可以有有限个元素，此时，元素的个数称为群的阶，记为$|G|$，也可以含有无限个元素。 给定群$G$，如果集合$H \\subseteq G$，且$H$中包含了单位元，$H$中每个元素的逆元也在$H$中，则称$H$为$G$的子群。 给定群$(G,\\cdot)$，求幂操作即对一个元素$a$应用$n$次运算符$cdot$，表示为 \\begin{equation} a^n = \\underbrace{a\\cdot a \\cdot a \\cdots a}_{n} \\end{equation} 特别的，$a^0=e$ 循环群：是指能由群中的某个元素做幂运算而生成的群，例如整数加群$(\\mathbb{Z},+)$是一个无限循环群，生成元为$1$或$-1$ 拉格朗日定理：设$H$是有限群$G$的一个子群，则$H$的阶整除$G$的阶。 推论1：若$a$是有限群$G$的一个元素，则$a$的阶整除$G$的阶。 推论2：阶为质数的群都是循环群。 推论3：费马小定理是拉格朗日定理的一个简单推论 ","date":"2022-10-30","objectID":"/ecc/:0:1","tags":null,"title":"理解椭圆曲线密码","uri":"/ecc/"},{"categories":null,"content":"环 环是由集合$R$和定义在$R$的加法和乘法两种二元运算构成的，且满足以下性质的代数结构$(R,+,\\cdot)$： $(R,+)$构成交换群，其单位元记为$0$，$R$中元素$a$的加法逆元记为$-a$； $(R,\\cdot)$构成半群； 乘法对于加法满足分配律，即对所有的$a,b,c \\in R$有： $a \\cdot (b+c) = (a\\cdot b)+(a\\cdot c)$ $(a+b)\\cdot c = (a \\cdot c) + (b \\cdot c)$ 特殊的环 交换环：若环$(R,\\cdot)$满足交换律，则$R$称为交换环 幺环：若环$R$存在乘法单位元$1$，则称$R$为幺环。 除环：若幺环$R$的所有非零元素存在乘法逆元$a^{-1}$，则称$R$为除环。 ","date":"2022-10-30","objectID":"/ecc/:0:2","tags":null,"title":"理解椭圆曲线密码","uri":"/ecc/"},{"categories":null,"content":"域 在抽象代数中，域是一种集合，在这个集合中可以对集合的非零元素进行加减乘除，其运算定义与行为就如同有理数和实数一样。域是交换除环。 ","date":"2022-10-30","objectID":"/ecc/:0:3","tags":null,"title":"理解椭圆曲线密码","uri":"/ecc/"},{"categories":null,"content":"椭圆函数 在数学上，椭圆曲线为一平面代数曲线，由如下形式的方程定义： \\begin{equation} y^2=x^3+ax+b \\end{equation} 且满足其是无奇点的，即其图形没有尖点或自相交，代数上来说，这成立当且仅当判别式 \\begin{equation} \\Delta = -16(4a^3+27b^2) \\end{equation} 不等于$0$。 尖点和自相交 尖点：曲线中的一种奇点。曲线上的动点在移到尖点时会开始反向移动 自相交：在数学上是指曲线和自身相交叉的点，曲线的二个分支在此位置有不同的切线。叉点也称为平常二重点 椭圆曲线上的加法 任意取椭圆曲线上的两点$P$，$Q$（若$P$，$Q$两点重合，则做$P$点的切线）做直线交于椭圆曲线的另一点$R^{\\prime}$，过$R^{\\prime}$做$y$轴的平行线交于$R$，我们规定$P+Q=R$ 根据椭圆曲线加法法则，可知椭圆曲线无穷远点与椭圆曲线上一点$P$的连线交于$P^{\\prime}$，过$P^{\\prime}$做$y$轴的平行线交于$P$，所以有$0+P=p$。我们把无穷远点称为零点，把$P^{\\prime}$成为$P$的负元。 根据此法则，可知，如果椭圆曲线上的三个点$A$，$B$，$C$处于同一条直线上，那么他们的和等于零元。即$A+B+C=0$。 密码学中的椭圆曲线 密码学中的椭圆曲线是定义在有限域上的。有限域是一个有有限个元素的集合，下面定义一个整数模$p$的集合$\\mathbb{F}_p$，$p$是素数。 $\\mathbb{F}_p$中只有$p$个元素$0,1,2,3 \\cdots p-2,p-1$; $\\mathbb{F}_p$的加法法则是$a+b \\equiv c \\ (mod \\ p)$； $\\mathbb{F}_p$的加法法则是$a-b \\equiv c \\ (mod \\ p)$，即$a+(-b) \\equiv c \\ (mod \\ p)$； $\\mathbb{F}_p$的乘法法则是$a \\times b \\equiv c \\ (mod \\ p)$； $\\mathbb{F}_p$的除法法则是$a/b \\equiv c \\ (mod \\ p)$，即$a \\times b^{-1} \\equiv c \\ (mod \\ p)$； $\\mathbb{F}_p$的单位元是$1$，零元是$0$。 有限域上的椭圆函数可表示为： \\begin{equation} \\lbrace (x,y) \\in (\\mathbb{F})^2 | y^2=x^3+ax+b \\ (mod \\ p),4a^3+27b^2 \\not\\equiv 0 \\ (mod \\ p) \\rbrace \\cup \\lbrace 0 \\rbrace \\end{equation} 椭圆曲线上点的阶：如果椭圆曲线上一点$P$，存在最小的正整数$n$，使得$nP=P$，则称$n$为$P$的阶，在有限域上定义的椭圆曲线上的点的阶都是存在的 椭圆曲线有限域上的加法法则 设$P,Q \\in E_p(a,b)$，则 $P+0=P$ 如果$P=(x,y)$，那么$(x,y)+(x,-y)=0$，即$(x,-y)$是$P$的加法逆元，即$-P$； 设$P=(x_1,y_1)$，$Q=(x_2,y_2)$，$P\\neq -Q$，则$P+Q=(x_3,y_3)$由以下规则确定： \\begin{equation} x_3 \\equiv \\lambda^2 -x_1-x_2 \\ (mod \\ p) \\end{equation} \\begin{equation} y_3 \\equiv \\lambda (x_1-x_3) - y_1 \\ (mod \\ p) \\end{equation} 其中 \\begin{equation} \\lambda = \\begin{cases} \\frac{y_2-y_1}{x_2-x_1},\u0026 P \\neq Q \\\\ \\frac{3x_1^2+a}{2y_1}, \u0026 P = Q \\end{cases} \\end{equation} 椭圆曲线上的加解密 椭圆曲线加密的数学原理：椭圆曲线上的两个点$P$和$Q$，$k$为整数。 \\begin{equation} Q=kP \\end{equation} 点$P$称为基点，$k$为私有密钥，$Q$为公开密钥 给定$k$和$P$，根据加法法则，计算$Q$很容易 但给定$P$和$Q$，求$k$非常困难 现在描述利用椭圆曲线进行加密通信的过程 Alice选定一条椭圆曲线$E_p(a,b)$，并取椭圆曲线上一点，作为基点$G$； Alice选择一个私钥$k$，并生成公钥$K=kG$； ALice将$E_p(a,b)$和点$K$，$G$传给Bob； Bob收到消息后，将要传输的信息编码到$E_p(a,b)$上一点$M$，并产生一个随机整数$r$,$(r\u003cn)$； Bob计算点$C_1=M+rK$，$C_2=rG$； Bob将$C_1$，$C_2$传给Alice； Alice收到消息后，计算$C_1-kC_2$，结果就是$M$。 密码学中，描述一条$\\mathbb{F}_p$上的椭圆曲线，会用到六个参量 \\begin{equation} T=(p,a,b,G,n,h) \\end{equation} $p,a,b$用来确定一条椭圆曲线，$G$为基点，$n$为点$G$的阶，$h$是椭圆曲线上所有点的个数$m$模$n$的值。 以上参量值一般要求满足以下几个条件 $p$越大越安全，但越大计算速度越慢，200位左右即可； $pt \\neq 1 \\ (mod \\ n),\\ 1 \\le t \u003c 20$； $4a^3+27b^2 \\neq 0 \\ (mod \\ p)$； $n$为素数； $h \\le 4$。 ","date":"2022-10-30","objectID":"/ecc/:0:4","tags":null,"title":"理解椭圆曲线密码","uri":"/ecc/"},{"categories":null,"content":"参考文献 [1] [区块链] 密码学——椭圆曲线密码算法（ECC） [2] 群 [3] 环 [4] 域 [5] 椭圆曲线 [6] ECC椭圆曲线加密算法：有限域和离散对数 ","date":"2022-10-30","objectID":"/ecc/:0:5","tags":null,"title":"理解椭圆曲线密码","uri":"/ecc/"},{"categories":null,"content":"概述 RSA是一种广泛使用的非对称加密算法，由由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的，RSA就是他们三人姓氏头字母组成的。 对极大整数做因式分解的难度决定了RSA算法的可靠性，目前被破解的最长的RSA密钥为829位。只要密钥的长度足够长，用RSA加密的信息可以认为是无法破解的。下面将介绍与RSA算法相关的数学概念，RSA的算法流程及正确性证明。 ","date":"2022-10-29","objectID":"/rsa/:0:1","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"与RSA算法相关的数学概念 互质 如果两个正整数除了1之外，没有别的公因数，就称这两个数互质。关于互质，有以下几个推论： 任意两个质数构成互质关系； 一个数是质数，另一个数只要不是它的倍数，则这两个数互质； 如果两个数中，较大的那个数是质数，则这两个数互质； $1$和任意自然数互质； $p$是大于$1$的整数，则$p$和$p-1$互质； $p$是大于$1$的奇数，则$p$和$p-2$互质。 欧拉函数 算术基本定理 任意一个大于$1$的自然数，要么本身是质数，要么可以写成两个或以上质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。 在数论中，对正整数$n$，欧拉函数$\\varphi(n)$是小于等于$n$的正整数中与$n$互质的数的数目。 \\begin{equation} \\varphi(n)= p_1^{k_1-1}p_2^{k_2-1}\\cdots p_r{k_r-1}(p_1-1)(p_2-1)\\cdots(p_r-1) \\end{equation} $p_1，p_2 \\dots p_r$是$n$的质因子，该函数也可等价的写成 \\begin{equation} \\varphi(n)=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_r}) \\end{equation} 欧拉定理 欧拉定理是RSA算法的核心，理解了这个定理，就理解了RSA。欧拉定理指 如果两个正整数$a$和$n$互质，$\\varphi(n)$是$n$的欧拉函数，则 \\begin{equation} a^{\\varphi(n)} \\equiv 1 \\ (mod \\ n) \\end{equation} 欧拉定理有一个特殊情况，假设正整数$a$与质数$p$互质，因为质数$p$的欧拉函数$\\varphi(n)$等于$p-1$，则欧拉定理可以写成 \\begin{equation} a^{p-1} \\equiv 1 \\ (mod \\ n) \\end{equation} 这就是著名的费马小定理，它是欧拉函数的特例。 模反元素 如果两个正整数$a$和$n$互质，那么一定可以找到整数$b$，使得$ab-1$被$n$整除，这是$b$就叫做$a$的模反元素。 欧拉定理可以证明模反元素必然存在 \\begin{equation} a^{\\varphi(n)}=a \\times a^{\\varphi(n)-1} \\equiv 1 \\ (mod \\ n) \\end{equation} 可以看到，$a^{\\varphi(n)-1}$就是$a$的模反元素。 ","date":"2022-10-29","objectID":"/rsa/:0:2","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"RSA密钥生成步骤 随机选择两个不相等的质数$p$和$q$。 假设$p=61，q=53$ 计算$p$和$q$的乘积$n$，$n = pq = 61 \\times 53 = 3233$ 计算$n$的欧拉函数$\\varphi(n)$，根据公式$\\varphi(n)=(p-1)(q-1)=3120$ 欧拉函数性质 如果$p$为质数，则$\\varphi(p) = p-1$; 如果$n$可以分解成两个互质的整数$p$和$q$之积，则$\\varphi(n)=\\varphi(p)\\varphi(q)$ 在$1$到$\\varphi(n)$之间随机选择一个与$\\varphi(n)$互质的整数$e$ 计算$e$对于$\\varphi(n)$的模反元素$d$。 \\begin{equation} ed \\equiv 1 \\ (mod \\ \\varphi(n)) \\end{equation} 上式等价于 \\begin{equation} ed - 1 = k\\varphi(n) \\end{equation} 于是，找到模反元素$d$，实质上就是对下面这个二元一次方程求解 \\begin{equation} ex+\\varphi(n)y = 1 \\end{equation} 此方程可以用扩展欧几里得算法扩展求解，通过计算，得到$d=2753$。 将$n$和$e$封装成公钥，$n$和$d$封装成私钥。 ","date":"2022-10-29","objectID":"/rsa/:0:3","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"RSA算法的可靠性 公钥$(n，e)$是公开的，只要得知了$d$，就等于私钥泄露，即已知$n$和$e$，是否可能推导出$d$? Question $ed \\equiv 1 \\ (mod \\ \\varphi(n))$。只有知道$e$和$ \\varphi(n) $，才能算出$d$。 $n=pq$，只有将$n$因数分解，才能算出$p$和$q$。 如果$n$可以分解成两个互质的整数$p$和$q$之积，则$\\varphi(n)=\\varphi(p)\\varphi(q)$ 但是，分解质因数是很困难的，目前除了暴力破解没有别的办法，因此RSA算法的可靠性是基于这个困难的数学问题。 ","date":"2022-10-29","objectID":"/rsa/:0:4","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"RSA算法的加密与解密 假设要发送的信息是$m$，加密后的信息为$c$，则加密过程为 \\begin{equation} c=m^e \\ mod \\ n \\end{equation} Warning 由数论知识可知，$m \\ mod \\ n$的值域是$[0，n)$，因此$m$的值域不能超过$pm$的值域，否则将产生碰撞，即$m$必须小于$n$。 解密过程为 \\begin{equation} m = c^d \\ mod \\ n \\end{equation} ","date":"2022-10-29","objectID":"/rsa/:0:5","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"私钥解密的证明 证明私钥能解密，即是证明下式： \\begin{equation} c^d \\equiv m \\ (mod \\ n) \\end{equation} 由加密公式可得： \\begin{equation} c=m^e-kn \\end{equation} 将其代入解密公式(10)， \\begin{equation} (m^e-kn)^d \\equiv m \\ (mod \\ n) \\end{equation} 等价于 \\begin{equation} m^{ed} \\equiv m \\ (mod \\ n) \\end{equation} Tip 对$(m^e-kn)^d$二项式展开，除第一项外其他项都包含$kn$，都可以被$n$整除 由于 \\begin{equation} ed \\equiv 1 \\ (mod \\ \\varphi(n)) \\end{equation} 所以 \\begin{equation} ed = h\\varphi(n)+1 \\end{equation} 将上式代入(14)： \\begin{equation} m^{h\\varphi(n)+1} \\equiv m \\ (mod \\ n) \\end{equation} 接下来，分两种情况讨论， $m$和$n$互质 根据欧拉定理， \\begin{equation} m^{\\varphi(n)} \\equiv 1 \\ (mod \\ n) \\end{equation} 得到 \\begin{equation} (m^{\\varphi(n)})^h \\times m \\equiv m \\ (mod \\ n) \\end{equation} 得证。 $m$和$n$不是互质关系 由于$n=pq$，则$m$必然等于$kp$或$kq$。 假设$m=kp$，此时$k$和$q$必然互质，根据欧拉定理知： \\begin{equation} (kp)^{q-1} \\equiv 1 \\ (mod \\ q) \\end{equation} 进一步得到 \\begin{equation} [(kp)^{q-1}]^{h(p-1)} \\times kp \\equiv kp \\ (mod \\ q) \\end{equation} 将式(16)带入上式 \\begin{equation} (kp)^{ed} \\equiv kp \\ (mod \\ q) \\end{equation} 即 \\begin{equation} (kp)^{ed} \\equiv tq + kp \\end{equation} 这时$t$必然能被$p$整除，即有$t=t^{\\prime}p$ Tip 这是因为上式两边同时除以$p$，可知等式左边必然能够整除，因此右边$t\\frac{q}{p}+p$也必然是一个整数，又因为$p$和$q$互质，则$\\frac{t}{p}$必然是一个整数，才能保证等式成立。 因此上式可写为 \\begin{equation} (kp)^{ed} = t^{\\prime}pq+kp \\end{equation} 将$m=kp$，$n=pq$代入得 \\begin{equation} m^{ed}=t^{prime}n+m \\end{equation} 即 \\begin{equation} m^{ed} \\equiv m \\ (mod \\ n) \\end{equation} 得证。 ","date":"2022-10-29","objectID":"/rsa/:0:6","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"参考文献 [1] RSA算法原理（一） [2] RSA算法原理（二） [3] RSA算法的数学原理与证明 ","date":"2022-10-29","objectID":"/rsa/:0:7","tags":null,"title":"RSA算法的数学原理及证明","uri":"/rsa/"},{"categories":null,"content":"xxxxxxxxx $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\u003e\u003e B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} int main(){ printf(\"hello\"); } ","date":"2022-08-11","objectID":"/first/:0:0","tags":null,"title":"第一篇文章","uri":"/first/"},{"categories":null,"content":" 为了解决主从备份模型无法同时实现高吞吐量，高可用性和强一致性的问题，论文提出了一种链复制技术，其主要思路是所有节点链式连接，查询操作只发送到tail节点，而更新操作则从头节点head依次更新到tail，tail回复消息给客户端。 ","date":"2022-05-19","objectID":"/chain-replication/:0:0","tags":["分布式","Chain Replication","论文"],"title":"Chain Replication论文阅读笔记","uri":"/chain-replication/"},{"categories":null,"content":"链复制协议 如果集群中有T个节点，该协议最多容忍t-1个节点失效。节点间还要保持健壮的FIFO通信，该协议不区分发送失败和请求被忽略。 $ Hist_{objID}^{T} $表示TAIL通过的update请求序列，上标表示节点的序号。 $Pending_{objID}$表示链收到但是没有被TAIL处理的请求。 fail-stop 如果失败，宁可停止服务，也不能进行错误的状态转移(强一致性)， 环境有能力监测到故障。 处理节点故障 为了检测故障，该协议假设了一个永不会失败的master节点，其作用有： 监测节点失败 在删除失败节点后向链上的每个节点通知其新的前驱和后置节点 通知客户端链的首尾节点 头节点故障 头节点的后继节点成为新的头节点，可以看作是T2，对一致性没有影响。 尾节点故障 尾节点的前驱节点成为新的尾节点，由倒数第二个节点处理过的Pending请求会变成已被尾结点处理，也就是重复了T3，仍然满足一致性。 中间节点故障 每个节点都存储一个sent_i节点，保存发送给后继节点但没有被尾节点处理的请求。\rmaster告知节点S+你前面的S失败； S+通知master最后更新的请求序号sn； mater通知S-它的新角色以及sn； S+向S-同步至sn。 新增节点 新增节点$T^+$增加在链尾，尾节点$T$将$Hist_{objID}^T$复制到$Hist_{objID}^{T^+}$，在复制过程中，同步处理客户端的请求，并将更新加入到$Send_T$,满足$Hist_{objID}^T = Hist_{objID}^{T+} + Sent_T$ 之后，$T$丢弃查询请求，把$Sent_T$发送给$T^+$，master通知客户端$T^+$成为新的链尾。 ","date":"2022-05-19","objectID":"/chain-replication/:0:1","tags":["分布式","Chain Replication","论文"],"title":"Chain Replication论文阅读笔记","uri":"/chain-replication/"},{"categories":null,"content":" ZooKeeper是一个分布式开源协调服务，它为更加复杂的协调原语提供了一个简单高效的内核，并为开发者提供了API以便他们能开发自己的协调原语。 ","date":"2022-05-18","objectID":"/zookeeper/:0:0","tags":["分布式","ZooKeeper"],"title":"ZooKeeper论文阅读笔记","uri":"/zookeeper/"},{"categories":null,"content":"ZooKeeper服务 服务概览 ZooKeeper给clients提供一个数据节点(znode)集合的抽象，client可以对这些znode进行数据操作，这些节点按层次结构组织。 client可以创造两种znode, regular, client可以显式地创建和删除这些znode ephermeral,client可以显示地创建或删除，也可以让系统在创建了znode的session结束时自动删除 另外，client可以在创建znode时设置sequential flag，拥有sequential flag的znode会有一个单调增的sequence value,即父节点的sequence value小于子节点的值。 ZooKeeper实现了watch机制，client在数据变化时可以不用轮询就可以及时收到通知。一个watch只会在一个session中触发一次。如果在一个session中数据变化了两次，client只会收到一次通知，因为在数据第一次变化后watch已被触发失效了。 This is a tip session：一个client从连接到ZooKeeper到断开连接的过程称为一个session Client API create(path, data, flags)：在path下新建一个znode，将data保存在其中，flags用来设置znode类型，以及设置sequential标志； delete(path, version)：如果version参数匹配，删除path对应的znode； exists(path, watch)：检查path对应的znode是否存在，watch让client观测这个znode； getdata(path, watch)：返回znode对应的数据和元数据，包括版本信息； setdata(path, data, version): 如果version参数匹配，将data写入znode； getChildren(path, watch)：返回znode的子节点 sync(path)：等待所有未决的更新。 以上这些API都有阻塞和非阻塞两个版本。 ","date":"2022-05-18","objectID":"/zookeeper/:0:1","tags":["分布式","ZooKeeper"],"title":"ZooKeeper论文阅读笔记","uri":"/zookeeper/"},{"categories":null,"content":"ZooKeeper保证 所有更新串行写入； 同一个client的请求按先到先服务顺序执行 ","date":"2022-05-18","objectID":"/zookeeper/:0:2","tags":["分布式","ZooKeeper"],"title":"ZooKeeper论文阅读笔记","uri":"/zookeeper/"},{"categories":null,"content":"原语示例 配置管理 将所有配置存储到一个znode中，其他节点通过watch机制获取更新。 会合 有些分布式系统包含一个主节点和多个工作节点，但这些节点都通过一个调度器调度，工作节点不知道主节点的地址和端口等配置信息。因此可以将主节点信息放入一个znode，工作节点通过znode获取主节点信息。 组成员关系 当一个组成员进程启动时，会在组对应的znode下创建一个ephemeral类型的子节点，该进程结束后子节点自动删除。进程也可以通过组znode的子节点获取组信息。 简单锁 锁可以通过创建一个ephemeral znode实现，如果创建成功，client获取锁。如果已经存在锁，client只能等待之前的锁被删除后才能创建自己的锁。 读写锁 写锁与普通锁类似，与其他锁互斥。而读锁间互相兼容，与写锁互斥。 双栅栏 双栅栏用来保证多个client的计算同时开始和同时结束。client开始计算前添加znode到barrier的znode之下，结束计算时删除znode。当barrier的znode下的子节点数达到阈值后才会启动计算。client可以等待一个特殊的ready的znode的创建，当数量到达阈值后创建。client退出的时候需要等待子znode全部被删除，同样可以通过删除ready删除。 ","date":"2022-05-18","objectID":"/zookeeper/:0:3","tags":["分布式","ZooKeeper"],"title":"ZooKeeper论文阅读笔记","uri":"/zookeeper/"},{"categories":null,"content":"ZooKeeper实现 请求处理器 leader收到写入请求后，会将其转换为幂等的事务，根据请求内容计算出新的数据、版本号和时间戳，等待应用到数据库中。 原子广播 ZooKeeper使用原子广播协议Zab,Zab使用简单多数投票确保一致性。Zab保证广播收到和发出的顺序是一致的。leader节点广播之前需要确保已经收到了前一个leader的广播 多副本数据库 当服务器故障后，使用周期性的快照和快照之后的日志恢复。创建快照的时候并不需要锁定，因为事务都是幂等的，因此再次应用已经应用的修改没有影响。 客户端-服务器交互 当server执行一个写入操作时，会通知watch的client并清楚watch。每个服务器只负责通知自己连接的客户端； 每个读取请求对应着一个zxid，对应服务器上看到的最后一个写入事务的ID。因为读取是在服务器本地进行，可能在读取之前的一些写入没有同步到客户端连接的服务器，ZooKeeper提供了sync操作，保证sync之后的读取操作都能够获得发生在sync之前的写入结果； 如果一个client连接到一个新的server，新server通过比较zxid,server zxid要大于client zxid,确保它的view不能低于client的view； 在超时时间内，server没有收到client的消息，server就会认为client session failure。因此，client要在在没有活动时发送heartbeat避免超时。 ","date":"2022-05-18","objectID":"/zookeeper/:0:4","tags":["分布式","ZooKeeper"],"title":"ZooKeeper论文阅读笔记","uri":"/zookeeper/"},{"categories":null,"content":"About LoveIt","date":"2019-08-02","objectID":"/about/","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"一个普通计科研究生罢了 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]